#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
æµ‹è¯•ç±»è£…é¥°å™¨æ¨¡å‹å®šä¹‰åŠŸèƒ½
"""

import json
import inspect
from typing import Dict, Any, Optional

try:
    import rat_quickdb_py
    from rat_quickdb_py import (
        create_db_queue_bridge,
        register_model,
        string_field,
        integer_field,
        datetime_field,
        FieldDefinition,
        IndexDefinition,
    )
except ImportError as e:
    print(f"é”™è¯¯ï¼šæ— æ³•å¯¼å…¥ rat_quickdb_py æ¨¡å—: {e}")
    exit(1)


def model(table_name: Optional[str] = None,
         database_alias: str = "default",
         description: str = "",
         enable_cache: bool = True,
         cache_ttl: int = 300):
    """
    æ¨¡å‹è£…é¥°å™¨ï¼Œå°†Pythonç±»è½¬æ¢ä¸ºRAT QuickDBæ¨¡å‹

    Args:
        table_name: è¡¨åï¼Œé»˜è®¤ä¸ºç±»åçš„å°å†™
        database_alias: æ•°æ®åº“åˆ«å
        description: æ¨¡å‹æè¿°
        enable_cache: æ˜¯å¦å¯ç”¨ç¼“å­˜
        cache_ttl: ç¼“å­˜TTL
    """
    def decorator(cls):
        # æ”¶é›†å­—æ®µå®šä¹‰
        fields = {}

        # è·å–æ‰€æœ‰ç±»å±æ€§
        for name, value in cls.__dict__.items():
            if name.startswith('_'):  # è·³è¿‡ç§æœ‰å±æ€§
                continue

            # æ£€æŸ¥æ˜¯å¦æ˜¯å­—æ®µå®šä¹‰
            if hasattr(value, 'to_dict') and hasattr(value, 'field_type'):
                fields[name] = value
            elif hasattr(value, '__class__') and value.__class__.__name__ == 'PyFieldDefinition':
                fields[name] = value

        # æ”¶é›†ç´¢å¼•å®šä¹‰å’Œå¤„ç†Metaç±»é…ç½®
        indexes = []
        meta_class = getattr(cls, 'Meta', None)
        final_table_name = table_name or cls.__name__.lower()
        final_database_alias = database_alias
        final_description = description

        if meta_class:
            indexes = getattr(meta_class, 'indexes', [])

            # ä»Metaç±»è·å–å…¶ä»–é…ç½®
            table_name_from_meta = getattr(meta_class, 'table_name', None)
            if table_name_from_meta:
                final_table_name = table_name_from_meta

            database_alias_from_meta = getattr(meta_class, 'database_alias', None)
            if database_alias_from_meta:
                final_database_alias = database_alias_from_meta

            description_from_meta = getattr(meta_class, 'description', None)
            if description_from_meta:
                final_description = description_from_meta

        # è½¬æ¢å­—æ®µä¸ºå­—å…¸æ ¼å¼
        fields_dict = []
        for field_name, field_def in fields.items():
            if hasattr(field_def, 'to_dict'):
                field_dict = field_def.to_dict()
                field_dict['name'] = field_name
                fields_dict.append(field_dict)
            else:
                # åˆ›å»ºåŸºæœ¬çš„å­—æ®µå­—å…¸
                fields_dict.append({
                    'name': field_name,
                    'field_type': {
                        'type': 'String',
                        'required': True,
                        'unique': False,
                        'indexed': False
                    },
                    'description': f'{field_name}å­—æ®µ'
                })

        # è½¬æ¢ç´¢å¼•ä¸ºå­—å…¸æ ¼å¼
        indexes_dict = []
        for index in indexes:
            if isinstance(index, dict):
                indexes_dict.append(index)
            elif hasattr(index, 'to_dict'):
                indexes_dict.append(index.to_dict())

        # åˆ›å»ºæ¨¡å‹å…ƒæ•°æ®
        model_meta = {
            "table_name": final_table_name,
            "database_alias": final_database_alias,
            "description": final_description or f"{cls.__name__}æ¨¡å‹",
            "fields": fields_dict,
            "indexes": indexes_dict,
            "enable_cache": enable_cache,
            "cache_ttl": cache_ttl,
        }

        # æ³¨å†Œæ¨¡å‹
        try:
            response = register_model(model_meta)
            result = json.loads(response)

            if result.get("success"):
                print(f"âœ… æ¨¡å‹ {cls.__name__} æ³¨å†ŒæˆåŠŸ")
            else:
                print(f"âŒ æ¨¡å‹ {cls.__name__} æ³¨å†Œå¤±è´¥: {result.get('error')}")

        except Exception as e:
            print(f"âŒ æ³¨å†Œæ¨¡å‹ {cls.__name__} æ—¶å‘ç”Ÿé”™è¯¯: {e}")

        # ä¸ºç±»æ·»åŠ æœ‰ç”¨çš„å±æ€§å’Œæ–¹æ³•
        cls._model_meta = model_meta
        cls._fields = fields
        cls._table_name = final_table_name
        cls._database_alias = final_database_alias

        # æ·»åŠ ç±»æ–¹æ³•
        @classmethod
        def get_table_name(cls):
            return cls._table_name

        @classmethod
        def get_fields(cls):
            return cls._fields

        @classmethod
        def get_model_meta(cls):
            return cls._model_meta

        cls.get_table_name = get_table_name
        cls.get_fields = get_fields
        cls.get_model_meta = get_model_meta

        return cls

    return decorator


# æµ‹è¯•ç”¨ä¾‹
if __name__ == "__main__":
    print("ğŸš€ æµ‹è¯•ç±»è£…é¥°å™¨æ¨¡å‹å®šä¹‰åŠŸèƒ½")
    print("=" * 50)

    # æµ‹è¯•1ï¼šç®€å•è£…é¥°å™¨æ–¹å¼
    @model(table_name="test_users", database_alias="default", description="æµ‹è¯•ç”¨æˆ·è¡¨")
    class TestUser:
        name = string_field(required=True, unique=False, description="ç”¨æˆ·å§“å")
        age = integer_field(required=False, unique=False, description="ç”¨æˆ·å¹´é¾„")
        email = string_field(required=True, unique=True, description="ç”¨æˆ·é‚®ç®±")

        class Meta:
            table_name = "users_from_meta"  # è¿™ä¸ªåº”è¯¥è¦†ç›–è£…é¥°å™¨å‚æ•°
            description = "ç”¨æˆ·è¡¨ï¼ˆæ¥è‡ªMetaç±»ï¼‰"
            indexes = [
                {'fields': ['name'], 'unique': False},
                {'fields': ['email'], 'unique': True},
                {'fields': ['name', 'age'], 'unique': False}
            ]

    print(f"è¡¨å: {TestUser.get_table_name()}")
    print(f"å­—æ®µæ•°é‡: {len(TestUser.get_fields())}")
    print(f"æ¨¡å‹å…ƒæ•°æ®: {json.dumps(TestUser.get_model_meta(), indent=2, ensure_ascii=False)}")

    # æµ‹è¯•2ï¼šæ›´å¤æ‚çš„æ¨¡å‹
    @model(description="æ–‡ç« è¡¨")
    class Article:
        title = string_field(required=True, unique=False, description="æ–‡ç« æ ‡é¢˜")
        content = string_field(required=False, unique=False, description="æ–‡ç« å†…å®¹")
        author_id = string_field(required=True, unique=False, description="ä½œè€…ID")
        created_at = datetime_field(required=True, unique=False, description="åˆ›å»ºæ—¶é—´")

        class Meta:
            database_alias = "article_db"
            indexes = [
                {'fields': ['title'], 'unique': True},
                {'fields': ['author_id', 'created_at'], 'unique': False}
            ]

    print(f"\næ–‡ç« è¡¨å: {Article.get_table_name()}")
    print(f"æ–‡ç« è¡¨æ•°æ®åº“åˆ«å: {Article._database_alias}")

    # æµ‹è¯•3ï¼šæœ€ç®€å•çš„æ¨¡å‹
    @model()
    class SimpleModel:
        name = string_field(required=True)

    print(f"\nç®€å•æ¨¡å‹è¡¨å: {SimpleModel.get_table_name()}")

    print("\nâœ… è£…é¥°å™¨æµ‹è¯•å®Œæˆï¼")